# 算法注意点

- 先思考，写步骤，写代码
- 注意时间复杂度
- 思考逻辑最简洁的写法
- 看别人的



# 自反性、反自反性、传递性

> “任意”：∀；“存在”：∃。

设R是A上的关系：

**自反**：若∀x(x∈A→<x,x>∈R)，则称R在A上是自反的。

取A中任意一个元素x，在R中都满足（x，x），即称R是自反的。

反自反：若∀x(x∈A→<x,x>∉R)，则称R在A上是反自反的。

取A中任意一个元素x，在R中都不满足（x，x），即称R是反自反的。

传递性：∃x,y,z(<x,y>∉R，<y,z>∉R→<x,z>∉R)

存在x,y,z，<x,y>和<y,z>都属于R，存在<x,z>。

扩展资料

> 例1】设A＝｛1，2，3，4｝，下列几个是A上的二元关系。
>
> R1={<1，1>，<1，2>，<2，1>，<2，2>，<3，4>，<4，1>，<4，4>}；
>
> R2={<1，1>，<1，2>，<2，1>}；
>
> R3={<1，1>，<1，2>，<1，4>，<2，1>，<2，2>，<3，3>，<4，1>，<4，4>}；
>
> R4={<2，1>，<3，1>，<3，2>，<4，1>，<4，2>，<4，3>}；
>
> R5=(<1，1>，<1，2>，<1，3>，<1，4>，<2，2>，<2，3>，<2，4>，<3，3>，<3，4>，<4，4>}；
>
> R6={<3，4>};
>
> R7={<3，4>，<4，1>，<3，1>}。
>
> 解: 
>
> 关系R3，R5是自反的，因为它包括所有形如<a，a>的序对。关系R4，R6是反自反的，因为它不包括任何形如<a，a>的序对。
>
> 而关系R1，R2既不是自反的，也不是反自反的。因为R1中包含<1，1>、<2，2>、<4，4>，但不包含<3，3>；R2中包含<1，1>，但不包含<2，2>、<3，3>、<4，4>。
>
> R7传递性，存在<3，4>、<4，1>就必须存在<3，1>。

自反性和反自反性可以在关系图和关系矩阵上非常直观地反映出来。

自反就是每个元素都与自身有关系；反自反就是每个元素都与自身没有关系。注意，有些关系，满足既不是自反关系，又不是反自反关系。而空关系（关系集合中无元素），满足既是自反关系，又是反自反关系。



## 逻辑联词与分支

```java
boolean x, y;
// 否定 ﹁
	!x
// 合取 ∧
	x && y
// 析取 ∨
	x || y
// 条件 →	P→Q 若P则Q；充分条件；
    !(x == true && y == false)
// 双条件 ↔ 充要条件
	x ^ y (异或：相同为1)
```



